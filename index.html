<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KVS workspace - Advanced MCQ Extractor and Solver (Firebase Full Edition with Chat Sessions)</title>
    <style>
        :root {
            --bg-color: #f4f4f4;
            --text-color: #333;
            --container-bg: #fff;
            --button-bg: #3498db;
            --button-hover: #2980b9;
            --code-bg: #f8f8f8;
            --border-color: #ddd;
            --table-header-bg: #f2f2f2;
            --sidebar-bg: #2c3e50;
            --sidebar-text: #ecf0f1;
        }

        [data-theme="dark"] {
            --bg-color: #2c3e50;
            --text-color: #ecf0f1;
            --container-bg: #34495e;
            --button-bg: #2980b9;
            --button-hover: #3498db;
            --code-bg: #2c3e50;
            --border-color: #7f8c8d;
            --table-header-bg: #2c3e50;
            --sidebar-bg: #1a252f;
            --sidebar-text: #bdc3c7;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            transition: background-color 0.3s ease;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 250px;
            background-color: var(--sidebar-bg);
            color: var(--sidebar-text);
            padding: 20px;
            overflow-y: auto;
        }

        #main-content {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
        }

        h1, h2 {
            color: var(--text-color);
        }

        button {
            background-color: var(--button-bg);
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--button-hover);
        }

        input[type="text"], input[type="password"], input[type="email"] {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid var(--border-color);
            border-radius: 5px;
        }

        #imageGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }

        .image-container {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #imageGrid img {
            width: 100%;
            height: auto;
            display: block;
        }

        .image-controls {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
        }

        .image-control-btn {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .image-control-btn:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }

        .code-block {
            background-color: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', Courier, monospace;
            position: relative;
            font-size: 14px;
            line-height: 1.6;
        }

        .chat-session {
            padding: 10px;
            margin-bottom: 10px;
            background-color: var(--container-bg);
            border-radius: 5px;
            cursor: pointer;
        }

        .chat-session:hover {
            background-color: var(--button-hover);
        }

        .active-chat {
            background-color: var(--button-bg);
            color: white;
        }

        #promptBox {
            position: fixed;
            bottom: 0;
            right: 0;
            left: 250px;
            background-color: var(--container-bg);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #promptInput {
            flex-grow: 1;
            margin-right: 10px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="sidebar">
            <h2>Chat Sessions</h2>
            <button id="newChatBtn">+ New Chat</button>
            <div id="chatList"></div>
        </div>
        <div id="main-content">
            <h1>KVS workspace - Advanced MCQ Extractor and Solver</h1>
            
            <div id="authContainer">
                <div id="loginForm">
                    <h2>Login</h2>
                    <input type="email" id="loginEmail" placeholder="Email">
                    <input type="password" id="loginPassword" placeholder="Password">
                    <button onclick="login()">Login</button>
                    <button onclick="loginWithGoogle()">Login with Google</button>
                </div>
                <div id="signupForm">
                    <h2>Sign Up</h2>
                    <input type="email" id="signupEmail" placeholder="Email">
                    <input type="password" id="signupPassword" placeholder="Password">
                    <input type="tel" id="phoneNumber" placeholder="Phone Number (for OTP)">
                    <button onclick="signup()">Sign Up</button>
                </div>
                <div id="otpForm" style="display: none;">
                    <h2>Enter OTP</h2>
                    <input type="text" id="otpInput" placeholder="Enter OTP">
                    <button onclick="verifyOTP()">Verify OTP</button>
                </div>
            </div>

            <div id="userInfo" style="display: none;">
                <p>Logged in as: <span id="userEmail"></span></p>
                <button onclick="logout()">Logout</button>
            </div>

            <div id="appContent" style="display: none;">
                <input type="text" id="apiKey" placeholder="Enter your Gemini API Key" style="width: 100%; padding: 12px; margin-bottom: 20px; border-radius: 8px; border: 1px solid var(--border-color);">
                <select id="modelSelect" style="width: 100%; padding: 12px; margin-bottom: 20px; border-radius: 8px; border: 1px solid var(--border-color);">
                    <option value="gemini-1.5-pro-latest">Gemini 1.5 Pro</option>
                    <option value="gemini-1.0-pro-latest">Gemini 1.0 Pro</option>
                </select>
                <div>
                    <label for="pdfInput" class="file-input-label">
                        Upload PDF
                        <input type="file" id="pdfInput" accept=".pdf">
                    </label>
                    <label for="imageInput" class="file-input-label">
                        Add Images
                        <input type="file" id="imageInput" accept="image/*" multiple>
                    </label>
                    <button onclick="processMCQs(false)">Extract MCQs Only</button>
                    <button onclick="processMCQs(true)">Extract and Solve MCQs</button>
                    <button onclick="orderMCQs()">Order MCQs Numerically</button>
                    <button onclick="copyAllResults()">Copy All Results</button>
                    <button onclick="recheckSolutions()">Recheck Solutions</button>
                </div>
                <div id="imageGrid"></div>
                <div id="progressBar">
                    <div id="progressBarFill"></div>
                </div>
                <div id="progressText"></div>
                <div id="timerDisplay"></div>
                <div id="resultsContainer"></div>
            </div>
        </div>
    </div>
    <div id="promptBox">
        <input type="text" id="promptInput" placeholder="Enter your prompt for modifying MCQs...">
        <button onclick="processPrompt()">Process</button>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBSbpgNHrllE3LqE7AqvvJSFxOb3uHBWRs",
            authDomain: "corded-academy-404101.firebaseapp.com",
            projectId: "corded-academy-404101",
            storageBucket: "corded-academy-404101.appspot.com",
            messagingSenderId: "639823673602",
            appId: "1:639823673602:web:f97ee37fbd38ca0bca6a1b",
            measurementId: "G-8PBCR51KW5"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        let currentUser = null;
        let currentChatSession = null;
        let chatSessions = [];
        let images = [];
        let allResults = [];
        let promptImages = [];
        let processingQueue = [];
        let isProcessing = false;
        const RATE_LIMIT_DELAY = 1000;
        const IMAGE_PROCESSING_DELAY = 500;
        let startTime;
        let timerInterval;

        // Authentication functions
        function signup() {
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            const phoneNumber = document.getElementById('phoneNumber').value;

            if (!phoneNumber.startsWith('+91')) {
                alert('OTP verification is only available for Indian phone numbers (+91).');
                return;
            }

            auth.createUserWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    console.log('User signed up');
                    currentUser = userCredential.user;
                    sendOTP(phoneNumber);
                })
                .catch((error) => {
                    console.error('Error signing up:', error);
                    alert('Sign up failed: ' + error.message);
                });
        }

        function sendOTP(phoneNumber) {
            // In a real implementation, you would integrate with a service to send OTP
            // For this example, we'll simulate it
            alert('OTP sent to ' + phoneNumber);
            document.getElementById('otpForm').style.display = 'block';
        }

        function verifyOTP() {
            const otp = document.getElementById('otpInput').value;
            // In a real implementation, you would verify the OTP with your service
            // For this example, we'll simulate it
            if (otp === '123456') { // Example OTP
                showUserInfo(currentUser);
                createNewChatSession();
            } else {
                alert('Invalid OTP');
            }
        }

        function login() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            auth.signInWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    console.log('User logged in');
                    currentUser = userCredential.user;
                    showUserInfo(currentUser);
                    loadChatSessions();
                })
                .catch((error) => {
                    console.error('Error logging in:', error);
                    alert('Login failed: ' + error.message);
                });
        }

        function loginWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider)
                .then((result) => {
                    console.log('User logged in with Google');
                    currentUser = result.user;
                    showUserInfo(currentUser);
                    loadChatSessions();
                }).catch((error) => {
                    console.error('Error logging in with Google:', error);
                    alert('Google login failed: ' + error.message);
                });
        }

        function logout() {
            auth.signOut().then(() => {
                console.log('User signed out');
                currentUser = null;
                currentChatSession = null;
                chatSessions = [];
                showAuthForms();
            }).catch((error) => {
                console.error('Error signing out:', error);
            });
        }

        function showUserInfo(user) {
            document.getElementById('authContainer').style.display = 'none';
            document.getElementById('userInfo').style.display = 'block';
            document.getElementById('appContent').style.display = 'block';
            document.getElementById('userEmail').textContent = user.email;
        }

        function showAuthForms() {
            document.getElementById('authContainer').style.display = 'block';
            document.getElementById('userInfo').style.display = 'none';
            document.getElementById('appContent').style.display = 'none';
        }

        // Chat session functions
        function createNewChatSession() {
            const sessionName = prompt("Enter a name for the new chat session:", "New Chat");
            if (sessionName) {
                const newSession = {
                    name: sessionName,
                    userId: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    content: []
                };

                db.collection("chatSessions").add(newSession)
                    .then((docRef) => {
                        console.log("New chat session created with ID: ", docRef.id);
                        loadChatSessions();
                    })
                    .catch((error) => {
                        console.error("Error creating new chat session: ", error);
                        alert("Failed to create new chat session. Please try again.");
                    });
            }
        }

        function loadChatSessions() {
            db.collection("chatSessions")
                .where("userId", "==", currentUser.uid)
                .orderBy("lastUpdated", "desc")
                .get()
                .then((querySnapshot) => {
                    chatSessions = [];
                    querySnapshot.forEach((doc) => {
                        chatSessions.push({ id: doc.id, ...doc.data() });
                    });
                    displayChatSessions();
                    if (chatSessions.length > 0) {
                        loadChatSession(chatSessions[0].id);
                    } else {
                        createNewChatSession();
                    }
                })
                .catch((error) => {
                    console.error("Error loading chat sessions: ", error);
                    alert("Failed to load chat sessions. Please try again.");
                });
        }

        function displayChatSessions() {
            const chatList = document.getElementById('chatList');
            chatList.innerHTML = '';
            chatSessions.forEach((session) => {
                const sessionElement = document.createElement('div');
                sessionElement.className = 'chat-session';
                sessionElement.textContent = session.name;
                sessionElement.onclick = () => loadChatSession(session.id);
                
                const editButton = document.createElement('button');
                editButton.textContent = '✏️';
                editButton.onclick = (e) => {
                    e.stopPropagation();
                    editChatSessionName(session.id);
                };
                sessionElement.appendChild(editButton);
                
                chatList.appendChild(sessionElement);
            });
        }

        function loadChatSession(sessionId) {
            currentChatSession = chatSessions.find(session => session.id === sessionId);
            if (currentChatSession) {
                document.querySelectorAll('.chat-session').forEach(el => el.classList.remove('active-chat'));
                document.querySelector(`.chat-session:nth-child(${chatSessions.indexOf(currentChatSession) + 1})`).classList.add('active-chat');
                displaySessionContent();
            }
        }

        function displaySessionContent() {
            images = [];
            allResults = [];
            const imageGrid = document.getElementById('imageGrid');
            const resultsContainer = document.getElementById('resultsContainer');
            imageGrid.innerHTML = '';
            resultsContainer.innerHTML = '';

            currentChatSession.content.forEach(item => {
                if (item.type === 'image') {
                    addImageToGrid(item.data);
                } else if (item.type === 'result') {
                    addResultToContainer(item.data);
                }
            });
        }

        function editChatSessionName(sessionId) {
            const session = chatSessions.find(s => s.id === sessionId);
            const newName = prompt("Enter new name for the chat session:", session.name);
            if (newName && newName !== session.name) {
                db.collection("chatSessions").doc(sessionId).update({ 
                    name: newName,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                })
                .then(() => {
                    console.log("Chat session name updated successfully");
                    session.name = newName;
                    displayChatSessions();
                })
                .catch((error) => {
                    console.error("Error updating chat session name: ", error);
                    alert("Failed to update chat session name. Please try again.");
                });
            }
        }

        function saveToChatSession(content) {
            if (!currentChatSession) return;

            currentChatSession.content.push(content);
            db.collection("chatSessions").doc(currentChatSession.id).update({
                content: firebase.firestore.FieldValue.arrayUnion(content),
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            }).catch(error => {
                console.error("Error saving to chat session: ", error);
                alert("Failed to save content to chat session. Please try again.");
            });
        }

        // Image processing functions
        async function convertPDFToImages(file) {
            // Implement PDF to image conversion logic here
            // For this example, we'll just simulate it with a placeholder image
            const imageUrl = 'https://via.placeholder.com/150?text=PDF';
            addImageToGrid(imageUrl);
        }

        function addImageToGrid(src) {
            const imageGrid = document.getElementById('imageGrid');
            const container = document.createElement('div');
            container.className = 'image-container';

            const img = document.createElement('img');
            img.src = src;
            img.onload = function() {
                const imageFile = dataURLtoFile(img.src, `image_${Date.now()}.png`);
                images.push(imageFile);
            }

            const removeButton = document.createElement('button');
            removeButton.className = 'image-control-btn';
            removeButton.textContent = '×';
            removeButton.onclick = function() {
                container.remove();
                images = images.filter(img => img.name !== container.dataset.filename);
                saveToChatSession({ type: 'remove_image', data: container.dataset.filename });
            };

            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'image-controls';
            controlsDiv.appendChild(removeButton);

            container.appendChild(img);
            container.appendChild(controlsDiv);
            imageGrid.appendChild(container);

            saveToChatSession({ type: 'image', data: src });
        }

        function dataURLtoFile(dataurl, filename) {
            let arr = dataurl.split(','),
                mime = arr[0].match(/:(.*?);/)[1],
                bstr = atob(arr[1]), 
                n = bstr.length, 
                u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new File([u8arr], filename, {type:mime});
        }

        // MCQ processing functions
        async function processMCQs(withSolution) {
            const apiKey = document.getElementById('apiKey').value;
            const modelName = document.getElementById('modelSelect').value;
            const resultsContainer = document.getElementById('resultsContainer');

            if (!apiKey) {
                alert('Please enter API key.');
                return;
            }

            if (images.length === 0) {
                alert('Please add at least one image.');
                return;
            }

            resultsContainer.innerHTML = "<div class='code-block'>Processing MCQs from images...</div>";
            allResults = [];

            processingQueue = [...images];
            isProcessing = true;
            startTimer();
            updateProgressBar(0, images.length);

            await processNextImage(apiKey, modelName, withSolution);
        }

        async function processNextImage(apiKey, modelName, withSolution) {
            if (processingQueue.length === 0) {
                isProcessing = false;
                updateProgressBar(images.length, images.length);
                displayResults();
                stopTimer();
                playAlarmSound();
                saveToChatSession({ type: 'results', data: allResults });
                return;
            }

            const image = processingQueue.shift();

            try {
                const imageData = await getBase64(image);
                const processedMCQ = await callGeminiAPI(apiKey, modelName, imageData, image.type, withSolution);
                allResults.push(processedMCQ);
                updateProgressBar(images.length - processingQueue.length, images.length);
            } catch (error) {
                console.error(`Error processing image:`, error);
                if (error.message.includes('Rate limit exceeded')) {
                    processingQueue.unshift(image);
                    await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));
                } else {
                    allResults.push(`Error processing image: ${error.message}`);
                }
            }

            await new Promise(resolve => setTimeout(resolve, IMAGE_PROCESSING_DELAY));
            await processNextImage(apiKey, modelName, withSolution);
        }

        function getBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
            });
        }

        async function callGeminiAPI(apiKey, modelName, imageData, mimeType, withSolution) {
            const prompt = `Analyze this image containing multiple-choice questions (MCQs). Extract the questions, options, and ${withSolution ? 'provide solutions' : 'do not provide solutions'}. Follow these rules:

            1. Format each MCQ ${withSolution ? 'and its solution ' : ''}as a separate block.
            2. Left-align all content within each block.
            3. Use numbers (1, 2, 3, 4) instead of letters for options.
            4. Preserve the original question numbers from the image.
            5. ${withSolution ? 'Provide the solution directly after the options within the same block.' : 'Do not provide solutions.'}
            6. Indicate the correct answer with a green checkmark (✅) next to the correct option.
            7. If there's a table in the question, format it using HTML table tags. Use the class "mcq-table" for the table element.
            8. Use this format for your output:

            [Original Question number]. [Question text]
            [HTML table, if present]
            1. [Option 1]
            2. [Option 2]
            3. [Option 3]
            4. [Option 4] ✅ (if this is the correct answer)
            ${withSolution ? 'Solution: [Detailed explanation of the solution with complete calculations, presented line by line for readability]' : ''}

            9. Do not use LaTeX formatting. Present all content in plain text.
            10. Use '^' for exponents instead of HTML superscript tags. For example, write 'x^2' instead of 'x<sup>2</sup>'.
            11. If you detect a diagram or complex image in the question, add the fire emoji (🔥) at the beginning of the question text.
            ${withSolution ? '12. Prioritize accuracy in all calculations and logic.' : ''}
            13. Separate each MCQ block with two blank lines.
            14. Do not include phrases like "Therefore, the correct answer is...".

            Your primary goal is to provide accurate, well-formatted MCQs${withSolution ? ' and solutions' : ''} based on the image content provided.`;

            const maxRetries = 5;
            const baseDelay = 1000; // 1 second

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [
                                    { text: prompt },
                                    { inline_data: { mime_type: mimeType, data: imageData } }
                                ]
                            }],
                            generationConfig: {
                                temperature: 0.1,
                                topK: 40,
                                topP: 0.95,
                                maxOutputTokens: 8192,
                                stopSequences: []
                            }
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        if (response.status === 429) {
                            const delay = baseDelay * Math.pow(2, attempt);
                            console.log(`Rate limit exceeded. Retrying in ${delay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        throw new Error(`API error: ${response.status} - ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    return data.candidates[0].content.parts[0].text.trim();
                } catch (error) {
                    if (attempt === maxRetries - 1) {
                        throw error;
                    }
                }
            }
        }

        function displayResults() {
            const resultsContainer = document.getElementById('resultsContainer');
            resultsContainer.innerHTML = '';
            allResults.forEach((result, index) => {
                const codeBlock = document.createElement('div');
                codeBlock.className = 'code-block';
                codeBlock.innerHTML = `<div class="editable" contenteditable="true">${result}</div>`;
                
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.textContent = 'Copy';
                copyButton.onclick = () => copyToClipboard(result, copyButton);
                
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-button';
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => deleteResult(index);
                
                const editButton = document.createElement('button');
                editButton.className = 'edit-button';
                editButton.textContent = 'Save';
                editButton.onclick = () => saveEdit(index, codeBlock.querySelector('.editable'));
                
                const verifyButton = document.createElement('button');
                verifyButton.className = 'verify-button';
                verifyButton.textContent = 'Verify Solution';
                verifyButton.onclick = () => verifySolution(index);
                
                codeBlock.appendChild(copyButton);
                codeBlock.appendChild(deleteButton);
                codeBlock.appendChild(editButton);
                codeBlock.appendChild(verifyButton);
                resultsContainer.appendChild(codeBlock);
            });
        }

        function copyToClipboard(text, button) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            }, (err) => {
                console.error('Could not copy text: ', err);
                alert('Failed to copy text. Please try again.');
            });
        }

        function orderMCQs() {
            const orderedResults = allResults.flatMap(result => result.split('\n\n\n'))
                .filter(mcq => mcq.trim().match(/^\d+\./))
                .sort((a, b) => {
                    const numA = parseInt(a.match(/^(\d+)\./)[1]);
                    const numB = parseInt(b.match(/^(\d+)\./)[1]);
                    return numA - numB;
                });

            // Check for missing MCQs
            const numbers = orderedResults.map(mcq => parseInt(mcq.match(/^(\d+)\./)[1]));
            const maxNumber = Math.max(...numbers);
            for (let i = 1; i <= maxNumber; i++) {
                if (!numbers.includes(i)) {
                    console.warn(`MCQ number ${i} is missing`);
                }
            }

            allResults = [orderedResults.join('\n\n\n')];
            displayResults();
            saveToChatSession({ type: 'results', data: allResults });
        }

        function copyAllResults() {
            const allText = allResults.join('\n\n\n');
            copyToClipboard(allText, document.querySelector('.copy-button'));
        }

        function deleteResult(index) {
            allResults.splice(index, 1);
            displayResults();
            saveToChatSession({ type: 'results', data: allResults });
        }

        function saveEdit(index, editableDiv) {
            allResults[index] = editableDiv.innerText;
            displayResults();
            saveToChatSession({ type: 'results', data: allResults });
        }

        async function recheckSolutions() {
            const apiKey = document.getElementById('apiKey').value;
            const modelName = document.getElementById('modelSelect').value;

            if (!apiKey) {
                alert('Please enter API key.');
                return;
            }

            const reCheckedResults = [];
            for (let mcq of allResults.flatMap(result => result.split('\n\n\n'))) {
                try {
                    const recheckedMCQ = await callGeminiAPI(apiKey, modelName, mcq, 'text/plain', true);
                    reCheckedResults.push(recheckedMCQ);
                } catch (error) {
                    console.error(`Error rechecking MCQ:`, error);
                    reCheckedResults.push(`Error rechecking MCQ: ${error.message}`);
                }
                await new Promise(resolve => setTimeout(resolve, IMAGE_PROCESSING_DELAY));
            }

            allResults = [reCheckedResults.join('\n\n\n')];
            displayResults();
            saveToChatSession({ type: 'results', data: allResults });
        }

        async function verifySolution(index) {
            const apiKey = document.getElementById('apiKey').value;
            const modelName = document.getElementById('modelSelect').value;

            if (!apiKey) {
                alert('Please enter API key.');
                return;
            }

            const mcq = allResults[index];
            try {
                const verifiedMCQ = await callGeminiAPI(apiKey, modelName, mcq, 'text/plain', true);
                allResults[index] = verifiedMCQ;
                displayResults();
                saveToChatSession({ type: 'results', data: allResults });
            } catch (error) {
                console.error(`Error verifying solution:`, error);
                alert(`Error verifying solution: ${error.message}`);
            }
        }

        function editPrompt() {
            const promptInput = document.getElementById('promptInput');
            const promptPreview = document.getElementById('promptPreview');
            promptPreview.textContent = promptInput.value;
            promptPreview.style.display = 'block';
            promptInput.style.display = 'none';
        }

        async function processPrompt() {
            const apiKey = document.getElementById('apiKey').value;
            const modelName = document.getElementById('modelSelect').value;
            const promptInput = document.getElementById('promptInput');
            const promptPreview = document.getElementById('promptPreview');

            if (!apiKey) {
                alert('Please enter API key.');
                return;
            }

            const userPrompt = promptPreview.style.display === 'block' ? promptPreview.textContent : promptInput.value;
            if (!userPrompt && promptImages.length === 0) {
                alert('Please enter a prompt or upload an image.');
                return;
            }

            try {
                const currentMCQs = allResults.length > 0 ? allResults.join('\n\n') : "No MCQs extracted yet.";
                let imageData = [];

                for (let file of promptImages) {
                    imageData.push({
                        inline_data: {
                            mime_type: file.type,
                            data: await getBase64(file)
                        }
                    });
                }

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [
                                { text: `Current MCQs:\n\n${currentMCQs}\n\nUser prompt: ${userPrompt}\n\nInstructions:
                1. Process the MCQs according to the user's prompt.
                2. Only modify the questions specified in the prompt.
                3. For each modified question, create a new entry without changing the original.
                4. Do not include phrases like "Therefore, the correct answer is...".
                5. Maintain the original formatting and structure of the MCQs.
                6. If no MCQs exist, generate new ones based on the prompt.
                7. Return only the new or modified MCQs, not the entire set.
                8. If images are provided, analyze them and incorporate relevant information into the MCQs.
                9. Provide complete calculations in solutions, formatted line by line for readability.
                10. Use '^' for exponents instead of HTML superscript tags. For example, write 'x^2' instead of 'x<sup>2</sup>'.
                11. If you detect a diagram or complex image in the question, add the fire emoji (🔥) at the beginning of the question text.` },
                                ...imageData
                            ]
                        }],
                        generationConfig: {
                            temperature: 0.7,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 8192,
                            stopSequences: []
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API error: ${response.status} - ${JSON.stringify(errorData)}`);
                }

                const data = await response.json();
                const processedResult = data.candidates[0].content.parts[0].text.trim();
                allResults.push(processedResult);
                displayResults();
                promptInput.value = '';
                promptPreview.textContent = '';
                promptPreview.style.display = 'none';
                promptInput.style.display = 'block';
                clearPromptImages();
                saveToChatSession({ type: 'results', data: allResults });
            } catch (error) {
                console.error('Error processing prompt:', error);
                alert(`Error processing prompt: ${error.message}`);
            }
        }

        function clearPromptImages() {
            const promptImagesContainer = document.getElementById('promptImages');
            promptImagesContainer.innerHTML = '';
            promptImages = [];
            document.getElementById('promptImageInput').value = '';
        }

        function updateProgressBar(current, total) {
            const progressBar = document.getElementById('progressBarFill');
            const progressText = document.getElementById('progressText');
            const percentage = (current / total) * 100;
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = `Processing: ${current} / ${total} images`;
        }

        function startTimer() {
            startTime = Date.now();
            updateTimer();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function updateTimer() {
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const hours = Math.floor(elapsedTime / 3600);
            const minutes = Math.floor((elapsedTime % 3600) / 60);
            const seconds = elapsedTime % 60;
            document.getElementById('timerDisplay').textContent = 
                `Time elapsed: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function playAlarmSound() {
            const alarmSound = document.getElementById('alarmSound');
            alarmSound.play();
        }

        // Event listeners
        document.getElementById('newChatBtn').addEventListener('click', createNewChatSession);

        document.getElementById('pdfInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === 'application/pdf') {
                convertPDFToImages(file);
            } else {
                alert('Please upload a PDF file.');
            }
        });

        document.getElementById('imageInput').addEventListener('change', function(e) {
            Array.from(e.target.files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => addImageToGrid(event.target.result);
                    reader.readAsDataURL(file);
                }
            });
        });

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Check if user is already logged in
            auth.onAuthStateChanged((user) => {
                if (user) {
                    currentUser = user;
                    showUserInfo(user);
                    loadChatSessions();
                } else {
                    showAuthForms();
                }
            });
        });

        // Autosave when closing the browser or switching tabs
        window.addEventListener('beforeunload', function (e) {
            if (currentChatSession) {
                saveToChatSession({ type: 'autosave', data: { images, allResults } });
            }
        });
    </script>
</body>
</html>